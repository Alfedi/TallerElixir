#+Title: Fun with Elixir
#+Author: @Cuwano
#+Email:SexyACM@BestAsocEUW.io

#+LANGUAGE: es
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 8.3.2)
#+LATEX_CLASS_OPTIONS: [a4paper,hidelinks]

#+LATEX_CLASS_OPTIONS: [...,hidelinks]

#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_slide_number:h/v
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: timestamp:nil
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: linear
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 1
#+REVEAL_EXTRA_CSS: ./acm.css
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="EmacsFTW.">
#+REVEAL_PLUGINS: (markdown notes zoom multiplex classList highlight)


#+OPTIONS: toc:nil
# #+OPTIONS: reveal_single_file:t

* Dafuq is Elixir?
[[./images/dafuq_meme.jpg]]

/Elixir is a dynamic, functional language designed for building scalable and maintainable applications./
* Basic Elixir
** Pattern matching
#+BEGIN_SRC elixir
x = 1
# 1

1 = x
# 1

1 = y
# ** (CompileError) iex:3: undefined function y/0

2 = x
# ** (MatchError) no match of right hand side value: 1 ...
#+END_SRC

** Pattern matching
#+BEGIN_SRC elixir
{a, b} = {1, 2}
# {1, 2}

a
# 1

{a, b} = {1, 2, 3}
# ** (MatchError) no match of right hand side value: {1, 2, 3} ...

{c, _, _} = {3, 3, 6}
# {3, 3, 6}

c
# 3
#+END_SRC

** Atoms
#+BEGIN_SRC elixir
:ok
:hello
:this_is_an_atom

ThisIsAlsoAnAtom
Hello
#+END_SRC

** case clause
#+BEGIN_SRC elixir
  case {1, 2, 3} do
    {4, 5, 6} -> "Does not match"
    {1, x, 3} -> "Match and bind x to 2"
    _ -> "This will match any other value"
  end
  # "Match and bind x to 2"
#+END_SRC

** case clause
Match the value of a variable

#+BEGIN_SRC elixir
  x = 2

  case 2 do
    ^x -> "Will match"
    _ -> "This will match any other value"
  end
  # "Will match"
#+END_SRC

** case clause
Guards

#+BEGIN_SRC elixir
  case {1, 2, 3} do
    {1, x, 3} when x > 0 -> "Will match"
    _ -> "This will match any other value"
  end
  # "Will match"
#+END_SRC

** case clause
Atoms are useful here
#+BEGIN_SRC elixir
  case some_function() do
    {:ok, result} -> # Do something with result
    {:error, error_message} -> # Do something with error_message
  end
#+END_SRC

** Module definition and functions
#+BEGIN_SRC elixir
  # le_test.ex
  defmodule LeTest do
    def sum(a, b) do
      a + b
    end

    def sum({a, b}) do
      a + b
    end
  end
#+END_SRC

** Module definition and functions
#+BEGIN_SRC elixir
  # le_test.ex
  defmodule LeTest do
    # Arity 2
    def sum(a, b), do: a + b

    # Arity 1
    def sum({a, b}), do: a + b
    def sum(a), do: a + 1
    def sum(_), do: 0
  end
#+END_SRC

** Module definition and functions
#+BEGIN_SRC elixir
  LeTest.sum(1, 2)
  # 3

  LeTest.sum(1)
  # 2

  LeTest.sum({2, 2})
  # 4
#+END_SRC

** Module definition and functions
Guards are very useful in functions
#+BEGIN_SRC elixir
  # le_test.ex
  defmodule LeTest do
    def sum(a, b) when is_integer(a) and is_integer(b), do: {:ok, a + b}
    def sum(_, _), do: {:error, "I only accept integers"}
  end
#+END_SRC

** Anonymous functions
#+BEGIN_SRC elixir
  sum = fn a, b -> a + b end
  # #Function<20.128620087/0 in :erl_eval.expr/5>

  sum.(1, 2)
  # 3

  sum = & &1 + &2

  sum.(2, 2)
  # 4
#+END_SRC

** Anonymous functions
#+BEGIN_SRC elixir
  Enum.map([1, 2, 3], fn x -> x + 1 end)
  # [2, 3, 4]

  Enum.map([1, 2, 3], & &1 + 1)
  # [2, 3, 4]
#+END_SRC

* Processes
** Create processes
#+BEGIN_SRC elixir
  spawn(fn -> nil end)
  # #PID<0.214.0>
#+END_SRC

** Create processes
#+BEGIN_SRC elixir
  spawn(fn -> Enum.sum(1..100) end)
  # #PID<0.220.0>
#+END_SRC

** Send messages
#+BEGIN_SRC elixir
  father = self()
  spawn(fn ->
    sum = Enum.sum(1..100)
    send(father, sum)
  end)
  # #PID<0.231.0>

  flush
  # 5050
  # :ok
#+END_SRC

** Receive messages
#+BEGIN_SRC elixir
  father = self()
  spawn(fn ->
    sum = Enum.sum(1..100)
    send(father, sum)
  end)

  receive do
    num when is_integer(num) -> "Received the result #{num}"
    _ -> "Wut?"
  end
  # "Received the result 5050"
#+END_SRC

** Receive messages
#+BEGIN_SRC elixir
  pid =
    spawn(fn ->
      receive do
        {pid, :ping} ->
          send(pid, :pong)
      end
    end)
  # #PID<0.245.0>

  Process.alive?(pid)
  # true

  send(pid, {self(), :ping})
  # {#PID<0.180.0>, :ping}

  flush
  # :pong
  # :ok

  Process.alive?(pid)
  # false
#+END_SRC

** Receive messages
#+BEGIN_SRC elixir
  defmodule PingPong do
    def loop() do
      receive do
        {pid, :ping} ->
          send(pid, :pong)
          loop()

        {pid, :pong} ->
          send(pid, :ping)
          loop()
      end
    end
  end
#+END_SRC

** Maintain a state
#+BEGIN_SRC elixir
  defmodule PingPong do
    def loop(), do: loop({0, 0})
    def loop({pings, pongs} = state) do
      receive do
        {pid, :ping} ->
          send(pid, :pong)
          loop({pings + 1, pongs})

        {pid, :pong} ->
          send(pid, :ping)
          loop({pings, pongs + 1})
        {pid, :state} ->
          send(pid, state)
          loop(state)
      end
    end
  end
#+END_SRC

** Link a process
#+BEGIN_SRC elixir
  self()
  # #PID<0.101.0>

  pid = spawn(fn -> receive do :crash -> 1/0 end end)
  # #PID<0.140.0>

  Process.link(pid)
  # true

  send(pid, :crash)
  # 18:37:21.684 [error] Process #PID<0.140.0> raised an exception
  # ** (ArithmeticError) bad argument in arithmetic expression
  #     :erlang./(1, 0)

  self()
  # #PID<0.115.0>
#+END_SRC

** Link a process
Handle crashes, the magic ~:trap_exit~
#+BEGIN_SRC elixir
  self()
  # #PID<0.115.0>

  Process.flag(:trap_exit, true)
  # false

  pid = spawn(fn -> receive do :crash -> 1/0 end end)
  # #PID<0.140.0>

  Process.link(pid)
  # true

  send(pid, :crash)
  # 18:37:21.684 [error] Process #PID<0.140.0> raised an exception
  # ** (ArithmeticError) bad argument in arithmetic expression
  #     :erlang./(1, 0)

  self()
  # #PID<0.115.0>

  flush
  # {:EXIT, #PID<0.140.0>, {:badarith, [{:erlang, :/, [1, 0], []}]}}
  # :ok
#+END_SRC

* GenServer
** Create GenServers
Define GenServer module
~start_link~

** Send messages
~call~, ~cast~, ~send~

** Receive messages
~handle_call~, ~handle_cast~, ~handle_info~

** Maintain a state
** Link a GenServer
Handle errors

** Agents
Another implementation of GenServer

* Telegram Bots (Practice)
